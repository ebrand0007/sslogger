head	1.10;
access;
symbols;
locks
	ebrand:1.10; strict;
comment	@ * @;


1.10
date	2010.12.14.15.35.27;	author ebrand;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.14.14.53.43;	author ebrand;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.13.01.48.06;	author ebrand;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.11.22.02.54;	author ebrand;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.15.01.30.33;	author ebrand;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.16.02.20.33;	author ebrand;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.11.13.16.58;	author ebrand;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.09.02.28.39;	author ebrand;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.09.02.09.32;	author ebrand;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.08.03.01.29;	author ebrand;	state Exp;
branches;
next	;


desc
@before spelling changes
@


1.10
log
@clean version with signal handler
@
text
@/* Set terminal (tty) into "raw" mode: no line or other processing done
   Terminal handling documentation:
       curses(3X)  - screen handling library.
       tput(1)     - shell based terminal handling.
       terminfo(4) - SYS V terminal database.
       termcap     - BSD terminal database. Obsoleted by above.
       termio(7I)  - terminal interface (ioctl(2) - I/O control).
       termios(3)  - preferred terminal interface (tc* - terminal control).
       tty_ioctl
*/

#include <termios.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>

/*
 *  This file is part of sslogger
 * 
 *  sslogger is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  sslogger is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with sslogger.  If not, see <http://www.gnu.org/licenses/>.
 */


static struct termios orig_termios;  /* TERMinal I/O Structure */
static int fdtty = STDIN_FILENO;     /* STDIN_FILENO is 0 by default */
char up[]="\033[A"; /* Control chars */
char reset[]={0x1b,0x63}; /* Control chars */
int delayReplaySpeed=1200; //delay in replay speed, in microseconds
int defaultReplaySpeed=6000; //default sleep in replay
int maxDelaySpeed=200000; //max delay
int minDelaySpeed=0; //min delay
//int replyStepSpeed=1000; //step speed at which to change replay speed 
unsigned long int fileCharPos=0; //replay file char position
unsigned long int fileLinePos=0; //replay file line number
FILE *pfile; //FH pointer to file to replay
int debug=0;


/* prototypes */
void tty_make_raw(void);
void fail(char *mess);
int tty_restore(void);
void reset_tty(void);
void sreplay_atexit(void);
int replay(void);
int replat2delete(void);
int gotoLine(unsigned long int);
void termination_handler (int); /* signal handler function */


int playSpeed=0;

int main(int argc, char* argv[])
   {
    
    /* trap termination signals && reset tty */
    signal (SIGTERM, termination_handler);
    signal (SIGQUIT, termination_handler);
    signal (SIGHUP, termination_handler);
 
    char *mytty=ttyname(fileno(stdout));
    printf("Sending output to: %s\n",mytty);
    char *filename;
    if ( argc != 2 ) {
      fprintf(stderr, "Usage: %s <filename>\n",argv[0]);
      exit(EXIT_FAILURE);
    }
    //Get args
    filename=argv[1];     
    
    pfile = fopen(filename, "r");
    if (pfile == NULL) {
      perror(filename);
      fail("Could not open file\n");
    }  
    
    
    /* check that input is from a tty */
    if (! isatty(fdtty)) fail("not on a tty");

    /* store current tty settings in orig_termios */
    if (tcgetattr(fdtty,&orig_termios) < 0) fail("can't get tty settings");

    /* register the tty reset with the exit handler */
    if (atexit(sreplay_atexit) != 0) fail("atexit: can't register tty reset");

    tty_make_raw();      
    replay();   
    return 0;       /* sreplay_atexit will restore terminal */
   }

/******************************************************************/
/* exit handler for tty reset */
void sreplay_atexit(void)  /* NOTE: If the program terminates due to a signal   */
{                          /* this code will not runi, must use signal handler  */
  tty_restore();        
  reset_tty();
}                     


/******************************************************************/
void termination_handler (int signum)  { /* signal handler function */
switch(signum){
    if (debug>0) printf("Enter Signal termination_handler\n");
    case SIGHUP:
        /* reset terminal */
        sreplay_atexit();
        break;
    case SIGTERM:
        /* reset terminal */
        sreplay_atexit();
        break;
    case SIGQUIT:
        /* reset terminal */
        sreplay_atexit();
        break;
    case SIGINT:
        /* reset terminal */
        sreplay_atexit();
        break;
    }
    if (debug >0) printf("Exit Signal termination_handler\n");
    exit(0);
}
/******************************************************************/
/* Fatal error handler */
void fail(char *message)
{
  fprintf(stderr,"Error: %s\n",message);
  exit(1);
}

/******************************************************************/
/* Set the tty in raw mode */
void tty_make_raw(void)
{
  struct termios rawtty;
  
  rawtty = orig_termios;  /* copy original and then modify below */

  /* input modes - clear indicated ones giving: no break, no CR to NL, 
   *       no parity check, no strip char, no start/stop output (sic) control */
  rawtty.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
  
  /* output modes - clear giving: no post processing such as NL to CR+NL */
  rawtty.c_oflag &= ~(OPOST);
  
  /* control modes - set 8 bit chars */
  rawtty.c_cflag |= (CS8);
  
  /* local modes - clear giving: echoing off, canonical off (no erase with 
   *       backspace, ^U,...),  no extended functions, no signal chars (^Z,^C) */
  rawtty.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
  
  /* control chars - set return condition: min number of bytes and timer */
  //rawtty.c_cc[VMIN] = 5; rawtty.c_cc[VTIME] = 8; /* after 5 bytes or .8 seconds */
  /*  after first byte seen      */
  rawtty.c_cc[VMIN] = 0; rawtty.c_cc[VTIME] = 0; /* immediate - anything       */
  //rawtty.c_cc[VMIN] = 2; rawtty.c_cc[VTIME] = 0; /* after two bytes, no timer  */
  //rawtty.c_cc[VMIN] = 0; rawtty.c_cc[VTIME] = 8; /* after a byte or .8 seconds */

  /* put terminal in raw mode after flushing */
  if (tcsetattr(fdtty,TCSAFLUSH,&rawtty) < 0) fail("can't set raw mode");                                             
}

/******************************************************************/
/* Send reset to the TTY */
void reset_tty (void) {
  //reset terminal
  write (fdtty,&reset,2);
}

/******************************************************************/
/* restore tty to original tty settings */
int tty_restore(void)
   {
    /* flush and reset */
    if (tcsetattr(fdtty,TCSAFLUSH,&orig_termios) < 0) return -1;
    sleep(1); 
    return 0;
   }

/******************************************************************/
int help (void) {
  //reset terminal
  reset_tty();
  
  printf ("\r\n\r\nPress the following keys during the replay session:\r\n");   
  printf ("    f or /    Find a string (not implemented yet)\r\n");
  printf ("    n or /    Find the next match (not yet implemented)\r\n");
  printf ("    r or ?    Find backwards (not implemented yet)\r\n");
  printf ("    b         Back up 1 line\r\n");
  printf ("    <enter>   Display next line\r\n");
  printf ("    <anykey>  Display next char\r\n");
  printf ("    q         quit\r\n");
  printf ("    + or p    Starts auto-replay\r\n");
  printf ("    d         Toggle debug mode\r\n");
  printf ("\r\n");
  printf ("During playback:\r\n");
  printf ("    +         Increase playback speed\r\n");
  printf ("    -         Decrease playback speed\r\n");
  printf ("    <anykey>  End auto-replay \r\n");
  sleep(2);
  int c,answer;
  c=-1;
  while (c<1) {
    c=fgetc(stdin);
    answer=tolower(c);
    usleep(500);
  }
  
  return 1;
}
 
 /******************************************************************/
 int busy_wait(int u_seconds)
 {
   struct timeval start, end;
   gettimeofday(&start, NULL);
   long int start_usec=start.tv_usec;
   start_usec+=u_seconds;  //add the sleep time
   if (start_usec > 999999999) { //roll over the usec
      start.tv_sec++;
      start_usec-=999999999;
      start.tv_usec=start_usec;
   }
   while (1) {
     gettimeofday(&end, NULL);
     //if(start.tv_usec != end.tv_usec)
     if (start.tv_sec<end.tv_sec)
       break;
     else if(start_usec < end.tv_usec)
       break;
     sched_yield(); //yield some cpu time to other processes
   }
   //printf("\r\nStart =%06d:%07d, End =%07d:%07d\r\n",start.tv_sec, (int)start.tv_usec, end.tv_sec,(long)end.tv_usec);
   return 0;
 }
 /******************************************************************/
 void endOFile (void) {
   printf("\r\n\r\n<End of sreplay file>\r\n");
   //printf("charPos:%d lineNum:%d\r\n",fileCharPos,fileLinePos );
 }
 /******************************************************************/
 void my_usleep(unsigned long milliseconds)
 {
   /* issue usleeping <5000 ms on x86 */
   struct timespec tmReq;
   tmReq.tv_sec = (time_t)0;
   tmReq.tv_nsec = milliseconds;
   // we're not interested in remaining time nor in return value
   (void)nanosleep(&tmReq, (struct timespec *)NULL);
 }
 
 
 /******************************************************************/
 int gotoLine(unsigned long int seekTo) {
   int retVal=1;
   rewind(pfile); //set file pointer to the beginiinig
   //reset terminal
   reset_tty();
   fileCharPos=0;
   fileLinePos=0;
   //printf("seekTo: %d filecharPos:%d fileLinePos:%d\r\n",seekTo,fileCharPos,fileLinePos);
   while (fileLinePos<seekTo && retVal>0) {
     retVal=printNextLine();
     //printf("seekTo: %d filecharPos:%d fileLinePos:%d\r\n",seekTo,fileCharPos,fileLinePos);
     //sleep(1);
   }
   
   return 1; 
 }
 
 /******************************************************************/
 int gotoPos (unsigned long int pos) {
   int retVal=1;
   rewind(pfile); //set file pointer to the beginiinig
   reset_tty();
   fileCharPos=0;
   fileLinePos=0;
   while (fileCharPos<pos && retVal>0) {
     retVal=printNextChar();
   }
   //printf("filecharPos:%d pos:%d\r\n",fileCharPos,pos);
   return 1; 
 } 
 
/******************************************************************/   
int replay() 
{
  /* start loop  for cmd chars to run */
  int forever=1;
  char cmd;
  int bytesread=0;
  while (forever>0) { 
    /* don't do anything till we getc a char */
    bytesread=read(fdtty, &cmd, 1); /* read up to 1 byte */
    if (bytesread <0 ) fail("reading chars from tty");
    if (bytesread > 0) { //we have a char presses
            if (cmd=='q' || cmd=='Q' || cmd==3 ) {
              printf ("\r\nQuitting on user command\r\n");
              usleep(500);
              tcflush(STDIN_FILENO, TCIOFLUSH); /*clear tty buffer */
              break; // quit
            }
            else if (cmd==13) forever=printNextLine(); //-1 returned on eof
            else if (cmd=='+' || cmd=='p' || cmd=='P') forever=replayAtSpeed(defaultReplaySpeed); //-1 returned on eof
            else if (cmd=='b' || cmd=='B' ) {
              if (fileLinePos<2) {
                gotoLine(1);
              }
              else gotoLine(fileLinePos-2);
            }
            else if (cmd=='h') { 
              help();
              gotoPos(fileCharPos); 
            }
            else if (cmd=='d') {
               if (debug==0) debug=1;
               else debug=0;
            }
            /* else aother key was pressed,so print next char */
            else forever=printNextChar(); //-1 returns on eof
            cmd='\0';
    }
    my_usleep(500*1000);
  }
  
}

/******************************************************************/
int replayAtSpeed (int speed) {
  // replays file at speed: speed
  // returns -1 on EOF or quit
  // returns 1 on char press
  delayReplaySpeed=speed;
  int ch;
  int bytesread;
  while ((ch =fgetc(pfile))!=EOF) {
    //printf("Blocking tty read\n");
    char cmd;
    /*tty way */
    char a;
    a=toascii(ch);
    write(fdtty,&a,1); //print the char
    fileCharPos++; //increase the char position
    if (ch==13) { 
      fileLinePos++; //increase the line number 
    }
    if (debug>0) {
      printf ("\r\nREPLAYATAPWEED delayReplaySpeed=%d cmd=%d\n",delayReplaySpeed,cmd);
    }
    bytesread=0;
    bytesread = read(fdtty, &cmd, 1 /* read up to 1 byte */);
    if (bytesread>0) {

      if (cmd=='+') delayReplaySpeed=delayReplaySpeed/2; //double the play speed
      else if (cmd=='-') delayReplaySpeed=delayReplaySpeed*2; //cut the speed in half 
      else if (cmd=='q' || cmd=='Q' || cmd==3 ) {
        printf("\r\nQuitting on user command\r\n");
        return -1;
      }
      else if (cmd=='d') {
        if (debug==0) debug=1;
        else debug=0;
      }
#ifdef __linux__
      else if (cmd==27) {
        /* linux tty bug?? 
         * flush the in buffer, print the esc char, and continue */
        tcflush(STDIN_FILENO, TCIOFLUSH);
        a=toascii(ch);
        write(fdtty,&a,1); //print the char
        fileCharPos++; //increase the char position
        continue; 
      }
#endif
      else {
        if (debug>0) printf("\r\nExiting replayAtSpeeds. bytesread=%d cmd=%d\r\n",bytesread,(int)cmd);
        return 1; //pause    
      }
      if (delayReplaySpeed<minDelaySpeed) delayReplaySpeed=minDelaySpeed;
      if (delayReplaySpeed>maxDelaySpeed) delayReplaySpeed=maxDelaySpeed;
      if (debug>0)  {
          printf("\r\nSetting replay speed to:%d\r\n",delayReplaySpeed);
          sleep(1);
      }
    }
    if  (delayReplaySpeed > 999 ) my_usleep(delayReplaySpeed*1000); //min nanosleep on RHEL5
       else if (delayReplaySpeed > 1) busy_wait(delayReplaySpeed); //use busywait instead
  }
  endOFile();
  return 1; //1;
  
}



/******************************************************************/
int printNextLine() {
  // displays the next full line of text from the replay file
  // returns -1 on EOF
  int ch;
  while ((ch =fgetc(pfile))!=EOF) {
    /*tty way */
    char a;
    a=toascii(ch);
    write(fdtty,&a,1); //print the char
    fileCharPos++; //increase the char position
    if (ch==13) { 
      fileLinePos++; //increase the line number
      return 1;
    }
  }
  endOFile();
  return 1; //-1; //Assume we hit EOF
}

/******************************************************************/  
int printNextChar() {
  // Displays the next char from the replay file
  // returns -1 on EOF
  int ch;
  if ((ch =fgetc(pfile))==EOF) {
    endOFile();
    return 1; //eof hit
  }
  fileCharPos++; //increase the char position
  if (ch==13) fileLinePos++; //increase the line number
    /*tty way */
    char a;
  a=toascii(ch);
  
  
  write(STDOUT_FILENO,&a,1);
  
  if (!(isalnum(ch))) printNextChar(); //skip control chars, and others
    //if (iscntrl(ch)) printNextChar(); // also get next char if control char
  return 1;
}

/******************************************************************/

@


1.9
log
@before adding signal handler
@
text
@d48 1
d60 1
a60 1
int debug=0;
d67 6
a72 1
     
d107 2
a108 2
{                      /* this code will not run.  This is for exit()'s     */
  tty_restore();        /* only.  TODO: resetting the terminal after a signal, */
d110 1
a110 1
}                      /* a signal handler which calls sreplay_atexit is needed. */
d114 24
a349 2
  /* TODO: set up non blocking IO on solaris sparc */
  //printf("Blocking tty read\n");
a364 3
    /*TODO: old  and remove cause we have read(fttty :
     * cmd=getc(stdin); 
    */
a455 36
/* TODO: delete this sub */
int replay2delete(void)
{
  int bytesread;
  char c_in, c_out, up[]="\033[A";
  char eightbitchars[256];                  /* will not be a string! */
  
  /* A little trick for putting all 8 bit characters in array */
  {int i;  for (i = 0; i < 256; i++) eightbitchars[i] = (char) i; }
  
  for (;;)
  {bytesread = read(fdtty, &c_in, 1 /* read up to 1 byte */);
  if (bytesread < 0) fail("read error");
                          if (bytesread == 0)        /* 0 bytes inputed, must have timed out */
                          {c_out = 'T';           /* straight forward way to output 'T' */
                          write(STDOUT_FILENO, &c_out, 1);
                          }
                          else switch (c_in)         /* 1 byte inputed */
                          {case 'q' : return 0;   /* quit - no other way to quit - no EOF */
                          case 'z' :             /* tricky way to output 'Z' */
                            write(STDOUT_FILENO, eightbitchars + 'Z', 1);
                            sleep (1);
                            break;
                          case 'u' :
                            write(STDOUT_FILENO, up, 3);  /* write 3 bytes from string */
                            sleep (1);
                            break;
                          default :
                            c_out = '*';
                            write(STDOUT_FILENO, &c_out, 1);
                          }
  }
}

/******************************************************************/

@


1.8
log
@testing using read instead of getc
@
text
@a120 1
#ifdef __sun__
d143 1
a143 13
#else
/* assume __linux__ */
  rawtty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP
  | INLCR | IGNCR | ICRNL | IXON);
  rawtty.c_oflag &= ~OPOST;
  rawtty.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
  rawtty.c_cflag &= ~(CSIZE | PARENB);
  rawtty.c_cflag |= CS8;

/*
 * tcflush(STDIN_FILENO, TCIOFLUSH);
*/
#endif
d322 1
d325 1
a325 1
    int cmd=0;
d337 6
a342 2
    cmd=getc(stdin);
    if (cmd>0) {
d354 11
d366 1
a366 1
        if (debug>0) printf("\r\nExiting replayAtSpeeds\r\n");
d465 2
a466 1
/******************************************************************/@


1.7
log
@.98 release
@
text
@d54 1
a54 1
void tty_reset(void);
d59 1
a59 1

d94 1
a94 1
    replay();        
d102 2
a103 1
tty_restore();        /* only.  TODO: resetting the terminal after a signal, */
d120 1
a121 1
  
d123 1
a123 1
  
d192 1
d313 4
d346 3
d351 1
d353 19
a371 10
          else if (cmd=='-') delayReplaySpeed=delayReplaySpeed*2; //cut the speed in half 
          else if (cmd=='q' || cmd=='Q' || cmd==3 ) {
            printf("\r\nQuitting on user command\r\n");
            return -1;
          }
          else return 1; //pause    
          if (delayReplaySpeed<minDelaySpeed) delayReplaySpeed=minDelaySpeed;
                   if (delayReplaySpeed>maxDelaySpeed) delayReplaySpeed=maxDelaySpeed;
                   printf("\r\nSeting replay speed to:%d\r\n",delayReplaySpeed);
          //sleep(1);
a372 1
    cmd=0;
@


1.6
log
@*** empty log message ***
@
text
@d1 14
a15 3
#include <unistd.h>
#include <string.h>
#include <printf.h>
a16 8
#include <fcntl.h>
#include <stdlib.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <time.h>
#include <ctype.h>
#include <sched.h>
#include <sys/time.h>
d19 21
a39 40
    This file is part of sslogger

    sslogger is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    sslogger is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with sslogger.  If not, see <http://www.gnu.org/licenses/>.
*/

#define TTY_BUFSIZE     1024

//prototypes
int replay (const char *, const char *);
int help (void);
int myrestore_tty(void);
int printNextChar(void);
int printNextLine(void);
//int tty_get_state(struct termios *, int);
//int tty_set_state(struct termios *, int); 

struct termio tty_saved, tty_current; //man 3 termios
// static char		*in_buff,	/* line input/output buffers	*/
// 			*out_buff,
// 			*in_ptr,
// 			*out_ptr;
// static int		in_size,	/* buffer sizes and counters	*/
// 			out_size,
// 			in_cnt,
// 			out_cnt;
// int opt_v=0; //1 for debuggin
int fdtty; //fd of tty
int fdtty_r; //fd read of tty
int isrestored=0; //set to one when tty is restored
d48 12
a59 2
//TODO: get/set window size
//man tty_ioctl 
d63 35
d99 6
a104 29
int help (void) {
    //reset terminal
    char a=0x1b;
    char b=0x63;
    write(fdtty,&a,1);
    write(fdtty,&b,1);
    
    printf ("\r\n\r\nPress the following keys during the replay session:\r\n");   
    printf ("    f or /    Find a string (not implemented yet)\r\n");
    printf ("    n or /    Find the next match (not yet implemented)\r\n");
    printf ("    r or ?    Find backwards (not implemented yet)\r\n");
    printf ("    b         Back up 1 line\r\n");
    printf ("    <enter>   Display next line\r\n");
    printf ("    <anykey>  Display next char\r\n");
    printf ("    q         quit\r\n");
    printf ("    + or p    Starts auto-replay\r\n");
    printf ("\r\n");
    printf ("During playback:\r\n");
    printf ("    +         Increase playback speed\r\n");
    printf ("    -         Decrease playback speed\r\n");
    printf ("    <anykey>  End auto-replay \r\n");
    sleep(2);
    int c,answer;
    c=-1;
    while (c<1) {
        c=fgetc(stdin);
        answer=tolower(c);
        usleep(500);
    }
a105 2
    return 1;
}
d107 2
a108 1
int busy_wait(int u_seconds)
d110 2
a111 20
  struct timeval start, end;
  gettimeofday(&start, NULL);
  long int start_usec=start.tv_usec;
  start_usec+=u_seconds;  //add the sleep time
  if (start_usec > 999999999) { //roll over the usec
      start.tv_sec++;
      start_usec-=999999999;
      start.tv_usec=start_usec;
  }
  while (1) {
    gettimeofday(&end, NULL);
    //if(start.tv_usec != end.tv_usec)
    if (start.tv_sec<end.tv_sec)
      break;
    else if(start_usec < end.tv_usec)
      break;
    sched_yield(); //yield some cpu time to other processes
  }
  //printf("\r\nStart =%06d:%07d, End =%07d:%07d\r\n",start.tv_sec, (int)start.tv_usec, end.tv_sec,(long)end.tv_usec);
  return 0;
d113 1
d115 43
a157 3
void endOFile (void) {
    printf("\r\n\r\n<End of sreplay file>\r\n");
    //printf("charPos:%d lineNum:%d\r\n",fileCharPos,fileLinePos );
d159 1
d161 4
a164 7
void my_usleep(unsigned long milliseconds)
{
    struct timespec tmReq;
    tmReq.tv_sec = (time_t)0;
    tmReq.tv_nsec = milliseconds;
    // we're not interested in remaining time nor in return value
    (void)nanosleep(&tmReq, (struct timespec *)NULL);
d167 9
d178 28
a205 15
int gotoLine(unsigned long int seekTo) {
       int retVal=1;
       rewind(pfile); //set file pointer to the beginiinig
       //reset terminal
       char a=0x1b;
       char b=0x63;
       write(fdtty,&a,1);
       write(fdtty,&b,1);
       fileCharPos=0;
       fileLinePos=0;
       while (fileLinePos<seekTo && retVal>0) {
           retVal=printNextLine();
       }
       //printf("filecharPos:%d fileLinepos:%d\r\n",fileCharPos,fileLinePos);
       return 1; 
d207 111
a317 16
/******************************************************************/
int gotoPos (unsigned long int pos) {
       int retVal=1;
       rewind(pfile); //set file pointer to the beginiinig
       //reset terminal
       char a=0x1b;
       char b=0x63;
       write(fdtty,&a,1);
       write(fdtty,&b,1);
       fileCharPos=0;
       fileLinePos=0;
       while (fileCharPos<pos && retVal>0) {
           retVal=printNextChar();
       }
       //printf("filecharPos:%d pos:%d\r\n",fileCharPos,pos);
       return 1; 
d319 1
a319 2
/******************************************************************/
/******************************************************************/
d322 21
a342 18
    // replays file at speed: speed
    // returns -1 on EOF or quit
    // returns 1 on char press
    delayReplaySpeed=speed;
    int ch;
    while ((ch =fgetc(pfile))!=EOF) {
        int cmd=0;
        /*tty way */
        char a;
        a=toascii(ch);
        write(fdtty,&a,1); //print the char
        fileCharPos++; //increase the char position
        if (ch==13) { 
            fileLinePos++; //increase the line number 
        }
       cmd=getc(stdin);
       if (cmd>0) {
          if (cmd=='+') delayReplaySpeed=delayReplaySpeed/2; //double the play speed
d345 3
a347 3
              printf("\r\nQuitting on user command\r\n");
              return -1;
              }
d350 2
a351 2
          if (delayReplaySpeed>maxDelaySpeed) delayReplaySpeed=maxDelaySpeed;
          //printf("\r\nSeting replay speed to:%d\r\n",delayReplaySpeed);
d353 3
a355 3
       }
       cmd=0;
       if  (delayReplaySpeed > 999 ) my_usleep(delayReplaySpeed*1000); //min nanosleep on RHEL5
d357 4
a360 4
    }
    endOFile();
    return 1; //1;
    
d363 2
d367 12
a378 13
    // displays the next full line of text from the replay file
    // returns -1 on EOF
    int ch;
    while ((ch =fgetc(pfile))!=EOF) {
        /*tty way */
        char a;
        a=toascii(ch);
        write(fdtty,&a,1); //print the char
        fileCharPos++; //increase the char position
        if (ch==13) { 
            fileLinePos++; //increase the line number
            return 1;
        }
d380 3
a382 2
    endOFile();
    return 1; //-1; //Assume we hit EOF
d384 1
d387 9
a395 9
    // Displays the next char from the replay file
    // returns -1 on EOF
    int ch;
    if ((ch =fgetc(pfile))==EOF) {
        endOFile();
        return 1; //eof hit
    }
    fileCharPos++; //increase the char position
    if (ch==13) fileLinePos++; //increase the line number
d398 1
a398 8
    a=toascii(ch);
    write(fdtty,&a,1);
    if (!(isalnum(ch))) printNextChar(); //skip control chars, and others
    //if (iscntrl(ch)) printNextChar(); // also get next char if control char
    return 1;
}
/******************************************************************/
int replay(const char *name, const char *tty) {
a399 10
    pfile = fopen(name, "r");
    if (pfile == NULL) {
        perror(name);
        return -1;
    }
    
    if ( (fdtty=open(tty,O_WRONLY , 0666))  < 0 ) {
        printf ("unable to open tty: %s for writing\n",tty);
        return -1;
    }
d401 1
a401 4
    if ( (fdtty_r=open(tty,O_RDONLY , 0666))  < 0 ) {
        printf ("unable to open tty: %s for writing\n",tty);
        return -1;
    }
d403 2
a404 82
  /* Fetch the current state of the terminal. */
    if (tty_get_state(&tty_saved, fdtty) < 0) {
        fprintf(stderr, "Error: tty_open: cannot get current state!\n");
        return -1;
    }
    usleep(5000);
    //SET TERMINAL TO DISABLE RAW ECHO:
    tty_current.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP
                    | INLCR | IGNCR | ICRNL | IXON);
    tty_current.c_oflag &= ~OPOST;
    tty_current.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
    tty_current.c_cflag &= ~(CSIZE | PARENB);
    tty_current.c_cflag |= CS8;
  
    if (tty_set_state(&tty_current, fdtty) < 0) {
        fprintf(stderr, "Error: tty_open: cannot set tty state!\n");
       return -1;
    }
    
    /* start loop  for cmd chars to run */
    int forever=1;
    tcflush(fdtty, TCIOFLUSH);
    while (forever>0) { 
        /* don't do anything till we getc a char */
        int cmd=getc(stdin);
        if (cmd > 0) { //we have a char presses
            if (cmd=='q' || cmd=='Q' || cmd==3 ) {
                printf ("\r\nQuitting on user command\r\n");
                usleep(500);
                tcflush(fdtty, TCIOFLUSH);
                break; // quit
            }
            else if (cmd==13) forever=printNextLine(); //-1 returned on eof
            else if (cmd=='+' || cmd=='p' || cmd=='P') forever=replayAtSpeed(defaultReplaySpeed); //-1 returned on eof
            else if (cmd=='b' || cmd=='B' ) gotoLine(fileLinePos-2);
            else if (cmd=='h') { 
                help();
                gotoPos(fileCharPos); //TODO: use gotoPos
            }
            //a char was press, print next char
            else forever=printNextChar(); //-1 returned on eof
            
            
            cmd=-1;
        }
        my_usleep(500*1000);
    }
    sleep(1);
    //RESET THE TTY
    myrestore_tty();
    fclose (pfile);
    close(fdtty);
    close(fdtty_r);
    return 0;    
}

/******************************************************************/
int myrestore_tty(void) {
  usleep(1000);
  if (isrestored==1) {
      //printf ("\rAlready restored\n");
      return 1;
  }
  //printf ("\r\nRestoring Console Settings\n");
  

  //reset the tty to the previous state
  sleep (1);
  tty_set_state(&tty_saved, fdtty);

  //flush tty buffers
  int bytesInBuffer;
  (void) ioctl(fdtty_r, FIONREAD, &bytesInBuffer );
  //printf ("\nThere are %d bytes left in the buffer, flushing\n",bytesInBuffer);
  //tcflush(fdtty, TCIOFLUSH);
  isrestored=1;
  
  char a=0x1b;
  char b=0x63;
  write(fdtty,&a,1);
  write(fdtty,&b,1);
  usleep(1500);
a405 1
  
a408 9
/* Fetch the state of a terminal. */
int tty_get_state(struct termios *tty, int tty_fd)
{
  if (ioctl(tty_fd, TCGETA, tty) < 0) {
	//fprintf(stderr, "dip: tty_get_state: %s\n", strerror(errno));
	return(-1);
  }
  return(0);
}
d410 2
a411 2
/******************************************************************/
int tty_set_state(struct termios *tty, int tty_fd)
d413 28
a440 4
  if (ioctl(tty_fd, TCSETA, tty) < 0) {
	//fprintf(stderr, "dip: tty_set_state: %s\n", strerror(errno));
	fprintf(stderr, "tty_set_state\n");
	return(-1);
a441 2
  //tcdain(tty_fd);
  return(0);
d444 1
a444 32
/******************************************************************/
int main(int argc, char* argv[]) {
    if  (! isatty(fileno(stdout))) {
      printf("is not tty\n");
      return 1;
    }
  
    char *mytty=ttyname(fileno(stdout));
    printf("Sending output to: %s\n",mytty);
    char *filename;
    if ( argc != 2 ) {
        fprintf(stderr, "Usage: %s <filename>\n",argv[0]);
        exit(EXIT_FAILURE);
    }
    //Get args
    filename=argv[1];
    replay(filename,mytty);
    printf("End replay\n");
    usleep (5000);
    exit(EXIT_SUCCESS);
}


/* man tty_ioctl
   Buffer count and flushing
       FIONREAD  int *argp
              Get the number of bytes in the input buffer.
  //returns 0 on success, -1 on error
  int ioctl(int fd, int cmd, ...);
  int *bytesInBuffer;
  int ioctl(int fd, FIONRED,bytesInBuffer );
*/
@


1.5
log
@middle of making find work
before moving file pos to fpos_t type
@
text
@a39 3
int findForward (void);
char * readLine(FILE *);
int findNext (fpos_t *, char *);
d62 1
a62 2
unsigned long int posInLine=0; //position in current line
unsigned long int fileLineNum=0; //replay file line number
d129 1
a129 1
    //printf("charPos:%d lineNum:%d\r\n",fileCharPos,fileLineNum );
a143 1
       if (seekTo < 1) return 0;
d152 2
a153 2
       fileLineNum=0;
       while (fileLineNum<seekTo && retVal>0) {
d156 1
a156 1
       //printf("filecharPos:%d fileLinepos:%d\r\n",fileCharPos,fileLineNum);
d169 1
a169 2
       fileLineNum=0;
       posInLine=0;
a191 1
        posInLine++; //increment the  current position in the line
d193 1
a193 2
            fileLineNum++; //increase the line number 
            posInLine==0; //reset position in line back to the start
a228 1
        posInLine++; //increment the  current position in the line
d230 1
a230 2
            fileLineNum++; //increase the line number
            posInLine=0; //reset position in line back to the start
d247 1
a247 5
    posInLine++;
    if (ch==13) { 
        fileLineNum++; //increase the line number
        posInLine=0; //reset position in line back to the start
    }
a307 1
            else if (cmd=='/' || cmd=='f' ) findForward();
d309 1
a309 1
            else if (cmd=='b' || cmd=='B' ) gotoLine(fileLineNum-2);
a384 202

int
findReverse (void) {
  /* TODO: */
    /*
    store our current position (fileCharPos
    rewind the file
    serch for striug (find forward?)
      thisMatch=findNext(0,searchString) //returns -1 on not found
      //TODO this means findForward must return the position, not just doit
      if thisMatch<0, not found
    found? 
       if thisMach > fileCharPos - not found, error out : repteat
      else
        lastMatch=thisMatch;
          thisMatch=findForward
          if thisMatch > fileCharPos {use lastMatch}
          else
          {
             thisMatch=lastMach
             :repeat
          } 
          
  /* fileCharPos is current file pos
     fileLineNum is current Line number in file
     int ff_lineNum is the line number movinf foreard where the string is found, init to fileLineNum
     int ff_linePos is the posistion in the line where the string is found, initially set to posInLine
         need to add posInLine to the printNextChar sub, it is the current pos in the current line     
     //Start at fileCharPos
     */
     unsigned long int ff_lineNum=fileLineNum;  //set to the file line number where the string is found
     //TODO: delete: unsigned long int ff_LinePos=PosInLine //set to the position in the line where the strng is  found
     unsigned long int ff_fileCharPos=fileCharPos; //On success, set to the string position in the file if the string is found.
     char *position; //local
     char *line =(char*) calloc(0, sizeof(char) ); 
     char *searchString="booger";
     char ch;
     fpos_t t_position;
     fgetpos(pfile, &t_position); //backup current file position
     while (feof(pfile)==0) {
        int len=0;
        while ( (ch = fgetc(pfile) ) != EOF && ch != '\n') { //Read remainder of this Line into line
            line = (char*) realloc(line, sizeof(char) * (len + 2) );
            line[len++] = ch;
            line[len] = '\0';
            ff_fileCharPos++; // keep track of where we are in the file
            position=strstr(line,searchString);
            if (position==NULL) { //string not found

                continue; //not found yet
            }
            else { //we found a match
                /* rewind the file to fileCharPos */
                //printf ("foundString. pos=%d",ff_fileCharPos);
                fsetpos(pfile,&t_position); //set file piinter to where we started
                gotoPos(ff_fileCharPos+1); //TODO: + strinlen(searchString)? or index offset?
                return 1; //happy find

            }             
        } //end while 
        //printf("reading next line\n");
     } //end while not eof
     // reset file pointer to where we startes
     fsetpos(pfile,&t_position);
     return 0; // string not found
     //TODO: wrap around to begininnig of file
 }

/******************************************************************/

int
findForward (void) {
  /* TODO: retutn -1 on not found, pos at end of string if found. parameters startAt, and searchStrng */
  /* fileCharPos is current file pos
     fileLineNum is current Line number in file
     int ff_lineNum is the line number movinf foreard where the string is found, init to fileLineNum
     int ff_linePos is the posistion in the line where the string is found, initially set to posInLine
         need to add posInLine to the printNextChar sub, it is the current pos in the current line     
     //Start at fileCharPos
     */
     unsigned long int ff_lineNum=fileLineNum;  //set to the file line number where the string is found
     //TODO: delete: unsigned long int ff_LinePos=PosInLine //set to the position in the line where the strng is  found
     unsigned long int ff_fileCharPos=fileCharPos; //On success, set to the string position in the file if the string is found.
     char *position; //local
     char *line =(char*) calloc(0, sizeof(char) ); 
     char *searchString="booger";
     char ch;
     fpos_t t_position;
     fgetpos(pfile, &t_position); //backup current file position
     while (feof(pfile)==0) {
        int len=0;
        while ( (ch = fgetc(pfile) ) != EOF && ch != '\n') { //Read remainder of this Line into line
            line = (char*) realloc(line, sizeof(char) * (len + 2) );
            line[len++] = ch;
            line[len] = '\0';
            ff_fileCharPos++; // keep track of where we are in the file
            position=strstr(line,searchString);
            if (position==NULL) { //string not found

                continue; //not found yet
            }
            else { //we found a match
                /* rewind the file to fileCharPos */
                //printf ("foundString. pos=%d",ff_fileCharPos);
                fsetpos(pfile,&t_position); //set file piinter to where we started
                gotoPos(ff_fileCharPos+1);  //TODO: + strinlen(searchString)? or index offset?
                return 1; //happy find

            }             
        } //end while 
        //printf("reading next line\n");
     } //end while not eof
     // reset file pointer to where we startes
     fsetpos(pfile,&t_position);
     return 0; // string not found
     //TODO: wrap around to begininnig of file
 }
 
/******************************************************************/
int
findNext (fpos_t *t_position, char *searchString) {
     fpos_t t_currentPos;
     fgetpos(pfile,&t_currentPos); /* backup current position */
     fsetpos(pfile,t_position); /* seek to startAt */     
     char ch;
     char *position; 
     char *line =(char*) calloc(0, sizeof(char) ); 
     while (feof(pfile)==0) {
        int len=0;
        while ( (ch = fgetc(pfile) ) != EOF && ch != '\n') { //Read remainder of this Line into line
            line = (char*) realloc(line, sizeof(char) * (len + 2) );
            line[len++] = ch;
            line[len] = '\0';
            position=strstr(line,searchString);
            if (position==NULL) { //string not found

                continue; //not found yet
            }
            else { //we found a match
                /* rewind the file to fileCharPos */
                //printf ("foundString. pos=%d",ff_fileCharPos);
                fgetpos(pfile,t_position); /* get the current position  */
                fsetpos(pfile,&t_currentPos); //set file piinter to where we started
                return (1); //happy find

            }             
        } //end while 
        //printf("reading next line\n");
     } //end while not eof


    return -1; // not found
}
/******************************************************************/

     
  /*   
  char *find_haystack = "http://www.iota-six.co.uk";
  char *search_string = "iota-six";
  char *position;
  int index;

  position = strstr(find_haystack, search_string);

  if(position==NULL) {
    printf("%s not found in %s\n", search_string, find_haystack);
  }
  else {
    printf("Address of find_haystack: 0x%p\n", find_haystack);
    printf("Address of position: 0x%p\n", position);

    index = find_haystack - position; //pointer arithmetic! 


    if(index<0) {
      index = -index;       // take the positive value of index //
    }

    printf("First occurrence of %s in %s\n", search_string, find_haystack);
    printf("is at letter %d\n", index);
  }
}
*/

/******************************************************************/

char* readLine(FILE* file)
{
  /* read a line from file, alocate mem as we read */
  char* line = (char*) calloc(0, sizeof(char) );;
  char ch;
  int len = 0;

  while ( (ch = fgetc(file) ) != EOF && ch != '\n')
  {
    line = (char*) realloc(line, sizeof(char) * (len + 2) );
    line[len++] = ch;
    line[len] = '\0';
  }
  return line;
}
/******************************************************************/
a403 1
    return (0);
@


1.4
log
@start of making findForward work
@
text
@d40 3
d65 2
a66 1
unsigned long int fileLinePos=0; //replay file line number
d133 1
a133 1
    //printf("charPos:%d lineNum:%d\r\n",fileCharPos,fileLinePos );
d148 1
d157 2
a158 2
       fileLinePos=0;
       while (fileLinePos<seekTo && retVal>0) {
d161 1
a161 1
       //printf("filecharPos:%d fileLinepos:%d\r\n",fileCharPos,fileLinePos);
d174 2
a175 1
       fileLinePos=0;
d198 1
d200 2
a201 1
            fileLinePos++; //increase the line number 
d237 1
d239 2
a240 1
            fileLinePos++; //increase the line number
d257 5
a261 1
    if (ch==13) fileLinePos++; //increase the line number
d322 1
d324 1
a324 1
            else if (cmd=='b' || cmd=='B' ) gotoLine(fileLinePos-2);
d399 71
d472 86
a557 2
  /* TODO: */
  char *url = "http://www.iota-six.co.uk";
d562 1
a562 1
  position = strstr(url, search_string);
d565 1
a565 1
    printf("%s not found in %s\n", search_string, url);
d568 1
a568 1
    printf("Address of url: 0x%p\n", url);
d571 2
a572 1
    index = url - position; /* pointer arithmetic! */
d575 1
a575 1
      index = -index;       /* take the positive value of index */
d578 1
a578 1
    printf("First occurrence of %s in %s\n", search_string, url);
d582 1
d584 1
d586 15
a600 1

d621 1
@


1.3
log
@after code include cleanup
@
text
@d384 30
@


1.2
log
@before cleaning code
@
text
@d11 3
d38 3
a40 1
int tty_get_state(struct termios *, int);
d328 1
a328 1
    
@


1.1
log
@Initial revision
@
text
@d10 1
d35 1
a35 1
//int tty_get_state(struct termios *, int);
d51 1
a51 1
int delayReplaySpeed=1200; //delay in replay speed, in microsecnds
d66 1
a66 1
    //reset terminial
d72 1
a72 1
    printf ("\r\n\r\nPress the following keys durung the replay session:\r\n");   
d141 1
a141 1
       //reset terminial
d158 1
a158 1
       //reset terminial
d201 1
a201 1
          //printf("\r\nSeting replay spped to:%d\r\n",delayReplaySpeed);
d289 1
a289 1
    /* start loop looing for cmd chars to run */
d293 1
a293 1
        /* dont do anything till we getc a char */
d336 1
a336 1
  //reset the tty to the privious state
d342 1
a342 1
  int resultI=ioctl(fdtty_r, FIONREAD, &bytesInBuffer );
@
